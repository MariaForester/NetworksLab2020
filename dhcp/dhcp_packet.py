from binascii import unhexlify, hexlify
import logging
from socket import inet_aton, inet_ntoa
import struct

from dhcp.dhcp_collections import *


class DHCPPacket:
    op_code = 1  # 1 for DHCPREQUEST (from client), 2 for DHCPACK or DHCPNAK (to client)
    h_type = 1  # ethernet (10Mb) hardware type
    h_length = 6  # constant for this hardware type
    hops = 0  # set to 0 by client; used by relay agents to control the forwarding of message; == num of agents
    x_id = 0  # 32-bit identification generated by client; to match up the request with replies from server
    secs = 0  # number of seconds elapsed since a client began an attempt to acquire or renew a lease
    flags = 1  # 1 if client does not know his IP and server should broadcast; else set to 0 (unicast)
    cia_addr = '0.0.0.0'  # client ip; 0 if a client does not know his ip; else set tot current client ip address
    yia_addr = '0.0.0.0'  # 'your' ip; The IP address that the server is assigning to the client.
    sia_addr = '0.0.0.0'  # this address the client should use in the next step (may or may not be server who is
    # sending this reply.The sending server always includes its own IP address in the Server Identifier option.
    gia_addr = '0.0.0.0'  # gateway ip; to route messages when relay agents are involved to facilitate the communication
    cha_addr = 'FF:FF:FF:FF:FF:FF'  # client hardware address;
    s_name = None  # server can OPTIONALLY include its name (sample text/DNS domain name); or for option overload
    boot_file = None  # OPTIONALLY used by client to request particular type of boot file; by server to specify its path
    options = {}  # DHCP options; option_num : option_val

    def add_options(self, options):
        for option_tag, option_data in options.items():  # add options to dict
            if option_tag != 53:
                option_data = str(option_data)
            self.options[option_tag] = self.Option(option_tag, option_data)
        self.options[255] = self.Option(255)

    def clear_options(self):
        self.options.clear()

    def convert_to_bytes(self):
        byte_packet = bytearray(236)
        print('Converting message to bytes')
        byte_packet[0] = self.op_code
        byte_packet[1] = self.h_type
        byte_packet[2] = self.h_length
        byte_packet[3] = self.hops
        print(f'op code, h_type, h_length, hops: {byte_packet[0:4]}')
        byte_packet[4:8] = struct.pack('!I', self.x_id)  # 32 bit number -> 4 byte; unsigned int
        print('x_id: ', byte_packet[4:8])
        byte_packet[8:10] = struct.pack('!H', self.secs)  # 2 bytes; unsigned short
        print('secs: ', byte_packet[8:10])
        byte_packet[10:12] = struct.pack('!H', self.flags)
        print('flags: ', byte_packet[10:12])
        byte_packet[12:16] = inet_aton(self.cia_addr)  # ip addr to bytes
        print('client ip: ', byte_packet[12:16])
        byte_packet[16:20] = inet_aton(self.yia_addr)
        print('your ip: ', byte_packet[16:20])
        byte_packet[20:24] = inet_aton(self.sia_addr)
        print('server ip: ', byte_packet[20:24])
        byte_packet[24:28] = inet_aton(self.gia_addr)
        print('gateway ip: ', byte_packet[24:28])
        byte_packet[28:34] = self.mac_to_bytes(self.cha_addr)  # mac addr to bytes
        byte_packet[34:44] = b'\0' * 10
        print('client mac: ', byte_packet[38:44])

        if self.s_name is not None:
            byte_packet[44:108] = bytes(self.s_name + '\0' * (64 - len(self.s_name)), 'utf-8')
        else:
            print('Adding padding instead of sname')
            byte_packet[44:108] = b'\0' * 64  # 64 0-s  --  padding
        if self.boot_file is not None:
            byte_packet[108:236] = bytes(self.boot_file + '\0' * (128 - len(self.boot_file)), 'utf-8')
        else:
            print('Adding padding instead of bootfile')
            byte_packet[108:236] = b'\0' * 128  # 128 0-s  --  padding
        byte_packet[236:240] = inet_aton(MAGIC_COOKIE)
        print(f'Magic cookie: {inet_aton(MAGIC_COOKIE)}')
        for option in self.options.values():
            current_option = option.get_option_bytes()
            byte_packet += current_option
        print('done converting to bytes')
        return byte_packet

    def mac_to_bytes(self, mac_string):
        mac_parts = mac_string.split(':')
        mac_byte_list = [bytes.fromhex(part) for part in mac_parts]
        return b''.join(mac_byte_list)

    def mac_from_bytes(self, mac_bytes):
        mac_string = ''
        for mac_byte in mac_bytes:
            mac_string += bytes([mac_byte]).hex()
            if mac_bytes.index(mac_byte) != len(mac_bytes) - 1:
                mac_string += ':'
        return mac_string

    def convert_from_bytes(self, byte_packet):
        print(byte_packet)
        self.op_code = byte_packet[0]
        self.h_type = byte_packet[1]
        self.h_length = byte_packet[2]
        self.hops = byte_packet[3]
        self.x_id = struct.unpack('!I', byte_packet[4:8])[0]
        self.secs = struct.unpack('!H', byte_packet[8:10])[0]
        self.flags = struct.unpack('!H', byte_packet[10:12])[0]
        self.cia_addr = inet_ntoa(byte_packet[12:16])
        self.yia_addr = inet_ntoa(byte_packet[16:20])
        self.sia_addr = (byte_packet[20:24])
        self.gia_addr = inet_ntoa(byte_packet[24:28])
        print(f'gia addr: {self.gia_addr}')
        print(byte_packet[38:44])
        self.cha_addr = self.mac_from_bytes(byte_packet[28:34])
        print(f'char addr: {self.cha_addr}')

        self.s_name = byte_packet[44:108]
        self.boot_file = byte_packet[108:236]

        decoded_cookie = inet_ntoa(byte_packet[236:240])
        print('decoded cookie: ', decoded_cookie)

        index = 240
        self.options.clear()
        while index < len(byte_packet):
            tag = byte_packet[index]
            if tag != 255 and tag != 0:
                data_len = byte_packet[index + 1]
                if tag == 53:
                    data = int.from_bytes(byte_packet[index + 2:index + 2 + data_len], byteorder='big')
                else:
                    data = byte_packet[index + 2:index + 2 + data_len].decode('utf-8')
                index += 2 + data_len
                print(f'optios decoded: tag={tag}, len: {data_len}, data={data}')
            else:
                data = None
                index += 1
            self.options[tag] = self.Option(tag, data)
        print('done converting from bytes')

    class Option:
        tag = None
        len = None
        data = None

        def __init__(self, tag, data=None):
            self.tag = int(tag)
            if data is not None:
                self.len = len(data) if tag != 53 else 1
                self.data = data
                print(f'adding option. tag:{tag}, data:{data} len: {self.len}, type of data: {type(data)} ')

        '''If we have 0 or 255 in the tag field, there is no value
         If 0: such option will simply be skipped
         If 255: the sign that that was the last option in the options list'''

        def get_option(self):
            return (self.tag, self.len, self.data) if self.data is not None else [self.tag]

        def get_option_bytes(self):
            if not self.data:
                return bytes([self.tag])
            else:
                print(f'tag: {self.tag}, len: {self.len}, data: {self.data}, type of data: {type(self.data)}')
                if self.tag == 53:
                    return bytes([self.tag, self.len, self.data])
                else:
                    data = bytes(self.data, 'utf-8')
                    bytes_arr = bytes([self.tag, len(data)])
                    bytes_arr += data
                    return bytes_arr
