from binascii import unhexlify
from socket import inet_aton
import struct

from dhcp.dhcp_collections import options_dict

MAGIC_COOKIE = '99.130.83.99'


class DHCPPacket:
    op_code = 1  # 1 for DHCPREQUEST (from client), 2 for DHCPACK or DHCPNAK (to client)
    h_type = 1  # ethernet (10Mb) hardware type
    h_length = 6  # constant for this hardware type
    hops = 0  # set to 0 by client; used by relay agents to control the forwarding of message; == num of agents
    x_id = 0  # 32-bit identification generated by client; to match up the request with replies from server
    secs = 0  # number of seconds elapsed since a client began an attempt to acquire or renew a lease
    flags = 1  # 1 if client does not know his IP and server should broadcast; else set to 0 (unicast)
    cia_addr = '0.0.0.0'  # client ip; 0 if a client does not know his ip; else set tot current client ip address
    yia_addr = '0.0.0.0'  # 'your' ip; The IP address that the server is assigning to the client.
    sia_addr = '0.0.0.0'  # this address the client should use in the next step (may or may not be server who is
    # sending this reply.The sending server always includes its own IP address in the Server Identifier option.
    gia_addr = '0.0.0.0'  # gateway ip; to route messages when relay agents are involved to facilitate the communication
    cha_addr = 'FF:FF:FF:FF:FF:FF'  # client hardware address;
    s_name = None  # server can OPTIONALLY include its name (sample text/DNS domain name); or for option overload
    boot_file = None  # OPTIONALLY used by client to request particular type of boot file; by server to specify its path
    options = []  # DHCP options; option_num : option_val

    def add_options(self, options):
        for option in options:
            # add options to dict
            options.add()

    def convert(self):
        byte_packet = bytearray([self.op_code, self.h_type, self.h_length, self.hops])
        # byte_packet.append(struct.pack('<I', self.x_id))
        byte_packet += struct.pack('>I', self.x_id)  # 32 bit number -> 4 byte; unsigned int
        byte_packet += struct.pack('>H', self.secs)  # 2 bytes; unsigned short
        byte_packet += struct.pack('>H', self.flags)
        byte_packet += inet_aton(self.cia_addr)  # ip addr to bytes
        byte_packet += inet_aton(self.yia_addr)
        byte_packet += inet_aton(self.sia_addr)
        byte_packet += inet_aton(self.gia_addr)
        byte_packet += unhexlify(self.cha_addr.replace(':', '').replace('-', ''))  # mac addr to bytes
        if self.s_name is not None:
            byte_packet += bytes(self.s_name, 'utf-8')
        if self.boot_file is not None:
            byte_packet += bytes(self.boot_file, 'utf-8')
        byte_packet += inet_aton(MAGIC_COOKIE)
        for option in self.options:
            byte_packet += bytes(option.get_option())
        print(byte_packet)


class Option:
    tag = None
    len = None
    data = None

    def __init__(self, tag, data=None):
        self.tag = tag
        if data is not None:
            self.len = len(data)
            self.data = data

    '''If we have 0 or 255 in the tag field, there is not value
    if 0 in tag encountered, such option will simply be skipped
    if it is 255, it is the sign we reached the end of the option list'''

    def get_option(self):
        return [self.tag, self.len, self.data] if self.data is not None else [self.tag]
